# Fastfile for OFFLEASH iOS App
# https://docs.fastlane.tools

default_platform(:ios)

platform :ios do
  # ============================================
  # SETUP & CONFIGURATION
  # ============================================

  before_all do
    # Set up App Store Connect API Key
    if ENV["APP_STORE_CONNECT_API_KEY_ID"] && ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"]
      app_store_connect_api_key(
        key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
        issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
        key_filepath: ENV["APP_STORE_CONNECT_API_KEY_KEY_FILEPATH"] || "./fastlane/AuthKey.p8",
        in_house: false
      )
    end
  end

  # ============================================
  # BUILD LANES
  # ============================================

  desc "Build the app for testing (Debug)"
  lane :build_debug do
    build_app(
      scheme: "OFFLEASH",
      configuration: "Debug",
      skip_archive: true,
      skip_codesigning: true
    )
  end

  # ============================================
  # TESTFLIGHT LANES
  # ============================================

  desc "Push a new beta build to TestFlight"
  lane :beta do |options|
    # Increment build number
    increment_build_number(
      build_number: options[:build_number] || (latest_testflight_build_number + 1)
    )

    # Build the app
    build_app(
      scheme: "OFFLEASH",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "com.offleash.ios" => "match AppStore com.offleash.ios"
        }
      }
    )

    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: true,
      distribute_external: false
    )

    # Clean up
    clean_build_artifacts
  end

  desc "Push a new beta build to TestFlight (manual signing)"
  desc "Options:"
  desc "  groups: Comma-separated TestFlight group names to distribute to (e.g., 'Beta Testers,Internal')"
  desc "  build_number: Custom build number (default: timestamp)"
  desc "  changelog: What's new in this build"
  lane :beta_manual do |options|
    # Increment build number
    increment_build_number(
      build_number: options[:build_number] || Time.now.strftime("%Y%m%d%H%M")
    )

    # Build configuration - support both manual and automatic signing
    build_options = {
      scheme: "OFFLEASH",
      configuration: "Release",
      export_method: "app-store",
      derived_data_path: "./build/DerivedData",
      xcargs: "-parallelizeTargets -jobs #{`sysctl -n hw.ncpu`.strip}"
    }

    # If provisioning profile is set in environment, use manual signing for CI
    if ENV["APPLE_PROVISIONING_PROFILE_NAME"] || ENV["APPLE_PROVISIONING_PROFILE_UUID"]
      team_id = ENV["APPLE_TEAM_ID"] || "67C7724279"
      profile_name = ENV["APPLE_PROVISIONING_PROFILE_NAME"]
      profile_uuid = ENV["APPLE_PROVISIONING_PROFILE_UUID"]

      # Update project to use manual signing for CI (only OFFLEASH target)
      signing_opts = {
        use_automatic_signing: false,
        path: "OFFLEASH.xcodeproj",
        team_id: team_id,
        code_sign_identity: "Apple Distribution",
        targets: ["OFFLEASH"],
        build_configurations: ["Release"]
      }
      # Use UUID if available (more reliable), otherwise use name
      if profile_uuid
        signing_opts[:profile_uuid] = profile_uuid
      elsif profile_name
        signing_opts[:profile_name] = profile_name
      end
      update_code_signing_settings(signing_opts)

      # Build - SPM packages use their defaults (no signing needed)
      # Append team ID to existing xcargs (parallel build flags)
      build_options[:xcargs] = "#{build_options[:xcargs]} DEVELOPMENT_TEAM=#{team_id}"
      build_options[:export_options] = {
        teamID: team_id,
        signingStyle: "manual",
        signingCertificate: "Apple Distribution",
        provisioningProfiles: {
          "com.offleash.ios" => profile_name || profile_uuid
        }
      }
    else
      # Use automatic signing for local builds
      # Append provisioning flag to existing xcargs (parallel build flags)
      build_options[:xcargs] = "#{build_options[:xcargs]} -allowProvisioningUpdates"
    end

    # Build the app
    build_app(build_options)

    # Parse groups if provided
    groups = options[:groups] ? options[:groups].split(",").map(&:strip) : nil

    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: groups.nil?, # Wait if distributing to groups
      distribute_external: !groups.nil?,
      groups: groups,
      changelog: options[:changelog] || "Bug fixes and improvements"
    )

    # Clean up
    clean_build_artifacts

    if groups
      UI.success("ðŸš€ Build uploaded and distributed to: #{groups.join(', ')}")
    else
      UI.success("ðŸš€ Build uploaded to TestFlight!")
    end
  end

  # ============================================
  # CERTIFICATE MANAGEMENT
  # ============================================

  desc "Sync development certificates"
  lane :sync_dev_certs do
    match(type: "development", readonly: true)
  end

  desc "Sync App Store certificates"
  lane :sync_appstore_certs do
    match(type: "appstore", readonly: true)
  end

  desc "Create new certificates (run once for new projects)"
  lane :create_certs do
    match(type: "development", readonly: false)
    match(type: "appstore", readonly: false)
  end

  # ============================================
  # TESTING LANES
  # ============================================

  desc "Run unit tests"
  lane :test do
    run_tests(
      scheme: "OFFLEASH",
      device: "iPhone 15",
      clean: true
    )
  end

  desc "Run UI tests"
  lane :ui_test do
    run_tests(
      scheme: "OFFLEASH",
      device: "iPhone 15",
      only_testing: ["OFFLEASHUITests"],
      clean: true
    )
  end

  # ============================================
  # UTILITY LANES
  # ============================================

  desc "Increment version number"
  lane :bump_version do |options|
    increment_version_number(
      bump_type: options[:type] || "patch" # major, minor, patch
    )
  end

  desc "Get current version and build number"
  lane :version_info do
    version = get_version_number(target: "OFFLEASH")
    build = get_build_number
    UI.message("Version: #{version} (#{build})")
  end

  # ============================================
  # ERROR HANDLING
  # ============================================

  error do |lane, exception|
    UI.error("Lane #{lane} failed with error: #{exception.message}")
  end
end
